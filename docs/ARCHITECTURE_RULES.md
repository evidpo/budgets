# Правила архитектуры проекта "Семейные финансы"

## Общие принципы

### 1. Разделение ответственности
- Frontend: Next.js приложение с TypeScript
- Backend: Supabase (PostgreSQL + Auth + Edge Functions)
- Документация: в папке `docs/`

### 2. Структура проекта
```
budgets/
├── frontend/              # Next.js приложение
│   ├── pages/             # Страницы приложения (роутинг)
│   ├── components/        # React компоненты
│   ├── lib/               # Вспомогательные функции и типы
│   ├── hooks/             # Кастомные React хуки
│   ├── styles/            # Стили
│   └── public/            # Статические файлы
├── supabase/              # Конфигурация и миграции Supabase
│   ├── config.toml        # Конфигурация
│   ├── migrations/        # SQL миграции
│   ├── functions/         # Edge функции
│   └── seed.sql           # Демо данные
└── docs/                  # Документация
```

## Правила связывания

### 1. Структура URL
- `/accounts` - страница управления счетами
- `/transactions` - страница управления транзакциями
- `/budgets` - страница управления бюджетами
- `/categories` - страница управления категориями
- `/debts` - страница управления долгами
- `/rules` - страница управления правилами автокатегоризации
- `/reports` - страница отчетов
- `/import` - страница импорта данных

### 2. Именование файлов и папок
- Использовать kebab-case для имен файлов и папок
- Использовать PascalCase для имен компонентов
- Использовать camelCase для имен функций и переменных
- Использовать UPPER_SNAKE_CASE для констант

### 3. Структура компонентов
- Каждый раздел (счета, транзакции, бюджеты и т.д.) имеет свою подпапку в `components/`
- Компоненты именуются по шаблону: `{Entity}{Action}.tsx`
- Примеры: `AccountCard.tsx`, `TransactionItem.tsx`, `BudgetForm.tsx`

### 4. Структура API
- Использовать RESTful подход к API
- Использовать единый префикс `/api` для кастомных эндпоинтов
- Использовать Supabase RPC для сложных запросов
- Все эндпоинты должны возвращать JSON

## Правила работы с данными

### 1. Модель данных
- Каждая сущность имеет поле `household_id` для обеспечения изоляции данных между households
- Использовать RLS (Row Level Security) для ограничения доступа к данным
- Все основные сущности имеют поля `created_at`, `updated_at`, `version`
- Переводы хранятся как пара транзакций с общим `transfer_id`

### 2. Отношения между сущностями
```
USERS → MEMBERS ← HOUSEHOLDS
              ↓
        ACCOUNTS ← TRANSACTIONS → CATEGORIES
           ↓              ↓
        BALANCES      BUDGETS ↔ DEBTS
```

### 3. Правила работы с транзакциями
- Тип транзакции определяется знаком суммы: `amount > 0` = доход, `< 0` = расход
- Переводы состоят из двух транзакций с одинаковым `transfer_id`
- Переводы исключаются из расчетов бюджетов и отчетов доходов/расходов
- Транзакции связаны с household, счетом, опционально с категорией, долгом и участником

### 4. Правила работы с бюджетами
- Бюджет ≠ Счет. Бюджет — расчетный объект (не хранит деньги)
- Бюджеты могут фильтровать транзакции по счетам, по категориям (с поддеревом) или по их пересечению
- Поддержка переноса остатка (rollover) между периодами
- Бюджеты не учитывают переводы при расчете

## Правила безопасности

### 1. Аутентификация и авторизация
- Использовать Supabase Auth для аутентификации
- Использовать JWT токены для авторизации
- Реализовать систему ролей (владелец, редактор, наблюдатель)
- Использовать RLS для ограничения доступа к строкам

### 2. Защита данных
- Все данные шифруются на уровне базы данных
- Пароли хранятся в зашифрованном виде
- Токены хранятся только в виде хешей

## Правила производительности

### 1. Индексация
- Обязательные индексы для часто используемых полей:
  - `transactions(household_id,date DESC)`
  - `transactions(account_id)`
  - `transactions(category_id)`
  - `transactions(debt_id)`
  - `transactions(transfer_id)`
  - `transactions(member_id)`
  - `accounts(household_id, sort_order NULLS LAST, name)`
  - `budgets(household_id, sort_order NULLS LAST, name)`
  - `categories(household_id, path)`
  - `rules(household_id,type,is_active)`

### 2. Оптимизации
- Использовать курсорную пагинацию для списков
- Использовать виртуализацию списков при большом количестве элементов
- Использовать оптимистичные обновления на фронте
- Кэшировать часто используемые данные

## Правила расширяемости

### 1. Архитектурные допущения
- Возможность добавления мультивалютности в будущем
- Возможность добавления "конвертов" как отдельного типа счета
- Возможность перехода на UUID без смены API
- Возможность миграции категорий `path` → `ltree` без изменения внешних контрактов

### 2. Масштабируемость
- При росте объема данных возможна реализация материализованных представлений для отчетов
- Возможна реализация партиционирования `transactions` по дате/household
- Возможен переход с Supabase Realtime на собственный WS-хаб без смены клиентских контрактов